Configurando Suite de Testes
============================

Nós já falamos sobre a configuração de contextos múltiplos para uma única suite 
de testes em um :doc:`capítulo anterior </guides/4.contexts>`. Agora é a hora de 
falarmos sobre suite de testes mesmo. Uma suite de teste representa um grupo de 
funcionalidades concretas juntas com a informação de como as testar.

Com suites você pode configurar o Behat para testar diferentes tipos de funcionalidades 
utilizando diferentes tipos de contextos e fazendo-o em uma única execução. Suites de 
Testes são realmente poderosas e o ``behat.yml`` faz delas muito mais poderosas:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            principal_features:
                paths:    [ %paths.base%/features/principal ]
                contexts: [ PrincipalContext ]
            usario_features:
                paths:    [ %paths.base%/features/web ]
                filters:  { role: usuario }
                contexts: [ UsuarioContext ]
            administrador_features:
                paths:    [ %paths.base%/features/web ]
                filters:  { role: administrador }
                contexts: [ AdministradorContext ]

Caminhos de Suite
-----------------

Uma das configurações mais óbvias das suites é a configuração 
de ``caminhos``:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            principal_features:
                paths:
                    - %paths.base%/features
                    - %paths.base%/test/features
                    - %paths.base%/vendor/.../features

Como vocẽ pode imaginar, esta opção diz ao Behat onde é para buscar as funcionalidades 
de teste. Você poderia, por exemplo, dizer ao Behat para procurar no arquivo ``features/web`` 
por funcionalidades e testá-los com ``WebContext``:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            web_features:
                paths:    [ %paths.base%/features/web ]
                contexts: [ WebContext ]

You then might want to also describe some API-specific features in
``features/api`` and test them with an API-specific ``ApiContext``. Easy:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            web_features:
                paths:    [ %paths.base%/features/web ]
                contexts: [ WebContext ]
            api_features:
                paths:    [ %paths.base%/features/api ]
                contexts: [ ApiContext ]

This will cause Behat to:

#. Find all features inside ``features/web`` and test them using your
   ``WebContext``.

#. Find all features inside ``features/api`` and test them using your
   ``ApiContext``.

.. note::

    ``%paths.base%`` is a special variable in ``behat.yml`` that refers
    to the folder in which ``behat.yml`` is stored.

Path-based suites are an easy way to test highly-modular applications
where features are delivered by highly decoupled components. With suites
you can test all of them together.

Suite Filters
-------------

In addition to being able to run features from different directories,
we can run scenarios from the same directory, but filtered by specific
criteria. The Gherkin parser comes bundled with a set of cool filters
such as *tags* and *name* filters. You can use these filters to run
features with specific tag (or name) in specific contexts:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            web_features:
                paths:    [ %paths.base%/features ]
                contexts: [ WebContext ]
                filters:
                    tags: @web
            api_features:
                paths:    [ %paths.base%/features ]
                contexts: [ ApiContext ]
                filters:
                    tags: @api

This configuration will tell Behat to run features and scenarios
tagged as ``@web`` in ``WebContext`` and features and scenarios
tagged as ``@api`` in ``ApiContext``. Even if they all are stored
in the same folder. How cool is that? But it gets even better,
because Gherkin 4+ (used in Behat 3+) added a very special *role*
filter. That means, you can now have nice actor-based suites:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            user_features:
                paths:    [ %paths.base%/features ]
                contexts: [ UserContext ]
                filters:
                    role: user
            admin_features:
                paths:    [ %paths.base%/features ]
                contexts: [ AdminContext ]
                filters:
                    role: admin

A Role filter takes a look into the feature description block:

.. code-block:: gherkin

    Feature: Registering users
      In order to help more people use our system
      As an admin
      I need to be able to register more users

It looks for a ``As a ...`` or ``As an ...`` pattern and guesses its
actor from it. It then filters features that do not have the expected
actor from the set. In the case of our example, it basically means that
features described from the perspective of the *user* actor will
be tested in ``UserContext`` and features described from the
perspective of the *admin* actor will be tested in ``AdminContext``.
Even if they are in the same folder.

Suite Contexts
--------------

Being able to specify a set of features with a set of contexts for
these features inside the suite has a very interesting side-effect.
You can specify the same features in two different suites being tested
against different contexts *or* the same contexts configured differently.
This basically means that you can use the same subset of features to
develop different layers of your application with Behat:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            domain_features:
                paths:    [ %paths.base%/features ]
                contexts: [ DomainContext ]
            web_features:
                paths:    [ %paths.base%/features ]
                contexts: [ WebContext ]
                filters:
                    tags: @web

In this case, Behat will first run all the features from the ``features/``
folder in ``DomainContext`` and then only those tagged with ``@web`` in ``WebContext``.

Executing Suites
----------------

By default, when you run Behat it will execute all registered suites
one-by-one. If you want to run a single suite instead, use the ``--suite``
option:

.. code-block:: bash

    $ vendor/bin/behat --suite=web_features

Suite Initialisation
---------------------

Suites are a core part of Behat. Any feature of Behat knows about
them and can give you a hand with them. For example, if you defined
your suites in ``behat.yml`` before running ``--init``, it will actually
create the folders and suites you configured, instead of the default ones.

