Definindo Ações Reutilizáveis
=============================

:doc:`Gherkin language</guides/1.gherkin>` fornece uma maneira para descrever
o comportamento da sua aplicação em uma linguagem de negócios compreensível.
Mas como você testa se o comportamento descrito realmente é implementado?
Ou se esta aplicação satisfaz as expectativas de negócios descritas nos
cenários da funcionalidade? O Behat provê uma maneira para mapear suas
etapas de cenário (ações) 1-a-1 com o código PHP chamado na step definitions:

.. code-block:: php

    /**
     * @When eu fizer algo com :argumento
     */
    public function euFizerAlgoCom($argumento)
    {
        // fazer algo com o $argumento
    }

A Casa das Definições - A Classe ``FeatureContext``
---------------------------------------------------

As step definitions são apenas métodos normais de PHP. Eles são métodos 
de instâncias de em uma classe especial chamada :doc:`FeatureContext</guides/4.contexts>`.
Esta classe pode ser facilmente criada executando ``behat`` com o comando 
``--init`` do diretório do seu projeto:

.. code-block:: bash

    $ vendor/bin/behat --init

Depois de você executar este comando, o Behat vai configurar um diretório
``features`` dentro do seu projeto:

A recentemente criara ``features/bootstrap/FeatureContext.php`` terá
uma classe contexto inicial para você começar:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\SnippetAcceptingContext;
    use Behat\Gherkin\Node\PyStringNode;
    use Behat\Gherkin\Node\TableNode;

    class FeatureContext implements SnippetAcceptingContext
    {
        /**
         * Initializes context.
         */
        public function __construct()
        {
        }
    }

Todas step definitions e :doc:`hooks</guides/3.hooks>` necessárias 
para testar seu projeto contra suas funcionalidades serão 
representadas por métodos dentro desta classe.

Criando Sua Primeira Step Definition
------------------------------------

O principal objetivo da step definition é ser executada quando o 
Behat vê a sua etapa correspondente no cenário de execução. Contudo, 
não é apenas porque um método existe em ``FeatureContext`` que o Behat
irá encontrá-lo. O Behat precisa de uma forma de verificar se um 
método de classe concreta é adequado para uma etapa concreta em um 
cenário. O Behat corresponde os métodos do ``FeatureContext`` com a 
step definitions utilizando correspondência padrão.

Quando o Behat é executado, ele compara as linhas de etapas do Gherkin 
de cada cenário com os padrões vinculados a cada método em seu 
`` FeatureContext``. Se a linha do Gherkin satisfaz o padrão vinculado, 
a sua step definition correspondente é executada. Simples assim!

O Behat utiliza anotações php-doc para vincular padrões com os métodos
do ``FeatureContext``:

.. code-block:: php

    /**
     * @When eu fizer algo com :argumentoDoMetodo
     */
    public function algumMetodo($argumentoDoMetodo) {}

Vamos dar uma olhada neste código:

#. ``@When`` é uma palavra chave definida. Há 3 palavras-chave suportadas
   em anotações: ``@Given``/``@When``/``@Then``. Estas três palavras-chave 
   de definição atualmente são equivalentes, mas todas as três permanecem
   disponíveis para que a sua step definition permaneça legível.

#. O texto depois da palavra-chave é a etapa texto padrão(por exemplo:
   ``eu fizer algo com :argumentoDoMetodo``).

#. Todos os valores token do padrão (por exemplo ``:argumentoDoMetodo``) são 
   capturados e passados ao método argumento com o mesmo nome (``$argumentoDoMetodo``).

.. note::
    
    Note que o bloco de comentário inicia com ``/**``, e não o usual ``/*``.
    Isto é importante para o Behat ser capaz de analisar tais comentários como anotações!

Como você já deve ter notado, este padrão é bastante geral e seu método 
correspondente será chamado pelas etapas que contenham 
``...eu fizer algo com...``, incluindo:

.. code-block:: gherkin

    Given eu fizer algo com "string1"
    When eu fizer algo com 'alguma outra string'
    Then eu fizer algo com 25

A única diferença real entre essa etapa aos olhos do Behat é o 
texto token capturado. Este texto será passado para as etapas 
do método ao correspondente valor de argumento. No exemplo acima, 
``FeatureContext::algumMetodo()`` vai ser chamado três vezes,
em cada vez com um argumento diferente:

#. ``$context->algumMetodo($argumentoDoMetodo = 'string1');``.

#. ``$context->algumMetodo($argumentoDoMetodo = 'alguma outra string');``.

#. ``$context->algumMetodo($argumentoDoMetodo = '25');``.

.. note::

    Um padrão não pode determinar automaticamente o tipo de dados de 
    suas correspondências, então todos os argumentos dos métodos vem
    para o step definitions passados como strings. Até mesmo que seu 
    padrão corresponda a "500", que pode ser considerado como um 
    inteiro, '500' será passado como um argumento string para o 
    método step definitions.

    Isto não é uma funcionalidade ou limitação do Behat, mas sim
    uma forma inerente da string corresponder. É sua responsabilidade
    converter os arumentos string para inteiro, ponto flutuante ou 
    booleano onde for aplicável dado o código que você está testando. 

    A conversão de argumentos para tipos específicos pode ser
    feita usando `step argument transformations`_.

.. note::

    O Behat não diferencia palavras-chave da etapa quando corresponde 
    padrões para métodos. Assim uma etapa definida com ``@When``
    também poderia ser correspondida com ``@Given ...``, ``@Then ...``, 
    ``@And ...``, ``@But ...``, etc.

Sua step definitions também pode definir argumentos múltiplos argumentos 
para passar para o método ``FeatureContext`` correspondente:

.. code-block:: php

    /**
     * @When eu fizer algo com :argumentoString e com :argumentoNumero
     */
    public function algumMetodo($argumentoString, $argumentoNumero) {}

Você também pode especificar palavras alternativas e partes opcionais 
de palavras, como esta:

.. code-block:: php

    /**
     * @When aqui esta/estao :contador monstro(s)
     */
    public function aquiEstaoMonstros($contador) {}

Se você precisa de um algoritimo de correspondência muito mais 
complicado, você sempre pode usar a boa e velha expressão regular:

.. code-block:: php

    /**
     * @When /^aqui (?:esta|estao) (\d+) monstros?$/i
     */
    public function aquiEstaoMonstros($contador) {}

Definição de Fragmentos
-----------------------

Agora você sabe como escrever step definitions à mão, mas escrever
todos estes métodos raiz, anotações e padrões à mão é tedioso. O
Behat faz esta tarefa rotineira muito fácil e divertido com a 
geração de Definição de Fragmentos para você! Vamos fingir que 
você tenha esta funcionalidade:

.. code-block:: gherkin

    Funcionalidade:
      Cenário:
        Dado alguma etapa com um argumento "string"
        E uma etapa com número 23

Se a sua classe contexto implementa a interface 
``Behat\Behat\Context\SnippetAcceptingContext`` e você testa uma 
funcionalidade com etapas em falta no Behat:

.. code-block:: bash

    $ vendor/bin/behat features/exemplo.feature

O Behat vai providenciar fragmentos gerados automaticamente para 
sua classe contexto.

Ele não somente gera o tipo de definição adequada (``@Given``), 
mas também propõe um padrão com o token capturado (``:arg1``, 
``:arg2``), nome do método (``algumaEtapaComUmArgumento()``, 
``umaEtapaComNumero()``) e argumentos (``$arg1``, ``$arg2``), 
todos baseados no texto da etapa. não é legal?

A única coisa que falta para você fazer é copiar estes fragmentos 
de métodos para a sua classe ``FeatureContext`` e fornecer um 
corpo útil para eles. Ou melhor ainda, executar o behat com a
opção ``--append-snippets``:

.. code-block:: bash

    $ vendor/bin/behat features/exemplo.feature --dry-run --append-snippets

``--append-snippets`` diz ao behat para automaticamente adicionar
fragmentos dentro de sua classe contexto.

.. note::

    A implementação da interface ``SnippetAcceptingContext`` diz 
    ao Behat que seu contexto espera fragmentos a serem gerados 
    no seu interior. O Behat vai gerar padrões simples de fragmentos 
    para você, mas se a sua for uma expressão regular, o Behat pode
    gerar ao invés de você, se você implementar a interface 
    ``Behat\Behat\Context\CustomSnippetAcceptingContext`` e adicionar
    o método ``getAcceptedSnippetType()`` irá retornar a string ``"regex"``:

    .. code-block:: php

        public static function getAcceptedSnippetType()
        {
            return 'regex';
        }

Tipos de resultado da execução da etapa
---------------------------------------

Agora você sabe como mapear o código atual do PHP que vai ser 
executado. Mas como você pode falar exatamente o que "falhou" 
ou "passou" quando executou uma etapa? E como atualmente o 
Behat verifica se um passo é executado corretamente?

Para isto, nós temos tipos de execução de etapa . O Behat 
diferencia sete tipos de resultados de execuções de etapa: 
"`Successful Steps`_", "`Undefined Steps`_",
"`Pending Steps`_", "`Failed Steps`_", "`Skipped Steps`_", 
"`Ambiguous Steps`_" e "`Redundant Step Definitions`_".

Vamos usar nossa funcionalidade introduzida anteriormente 
para todos os exemplos a seguir:

.. code-block:: gherkin

    # features/exemplo.feature
    Funcionalidade:
      Cenário:
        Dado alguma etapa com um argumento "string"
        E uma etapa com número 23

Successful Steps
~~~~~~~~~~~~~~~~

Quando o Behat encontra uma step definition correspondente 
ele vai executá-la. Se o método definido **not** joga nenhuma 
``Exceção``, a etapa é marcada como bem sucedida (verde). 
O que você retornar de um método de definição não tem efeito 
sobre o status de aprovação ou reprovação do próprio.

Vamos simular que nossa classe contexto contenha o código abaixo:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /** @Given alguma etapa com um argumento :argumento1 */
        public function algumaEtapaComUmArgumento($argumento1)
        {
        }

        /** @Given uma etapa com numero :argumento1 */
        public function umaEtapaComNumero($argumento1)
        {
        }
    }

Quando você executar sua funcionalidade, você vai ver todas as 
etapas passadas serem marcadas de verde. Isso simplesmente porque
não foram lançadas exceções durante a sua execução.

.. note::

    Etapas passadas sempre são marcadas de **verde** se o seu console
    suportar cores.


.. tip::

    Habilite a extensão PHP "posix" para ver a saída colorida do Behat.
    Dependendo do seu Linux, Mac OS ou outro sistema Unix pode fazer 
    parte da instalação padrão do PHP ou um pacote ``php5-posix`` a parte.

Etapas Indefinidas
~~~~~~~~~~~~~~~~~~

Quando o Behat não pode achar uma definição correspondente, a etapa
é marcada como **indefinida**, e todas as etapas subsequentes do cenário
são **ignoradas**.

Vamos supor que temos uma classe contexto vaiza:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
    }

Quando você executar a sua funcionalidade, você terá 2 etapas 
indefinidas marcadas de amarelo.

.. note::

    Etapas indefinidas sempre são marcadas de **amarelo** se 
    o seu console suportar cores.

.. note::

    Todas as etapas seguintes de uma etapa indefinida não são 
    executadas, como o seguinte comportamento é imprevisível. 
    Estas etapas são marcadas como **ignoradas** (ciano).

.. tip::

    Se você usar a opção ``--strict`` com o Behat, etapas não 
    definidas vão fazer o Behat sair o código ``1``.

Pending Steps
~~~~~~~~~~~~~

When a definition method throws a
``Behat\Behat\Tester\Exception\PendingException`` exception, the step is
marked as **pending**, reminding you that you have work to do.

Let's pretend your ``FeatureContext`` looks like this:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;
    use Behat\Behat\Tester\Exception\PendingException;

    class FeatureContext implements Context
    {
        /** @Given some step with :argument1 argument */
        public function someStepWithArgument($argument1)
        {
            throw new PendingException('Do some string work');
        }

        /** @Given number step with :argument1 */
        public function numberStepWith($argument1)
        {
            throw new PendingException('Do some number work');
        }
    }

When you run your feature, you'll get 1 pending step that is marked yellow and
one step following it that is marked cyan.

.. note::

    Pending steps are always marked as **yellow** if colors are supported by
    your console, because they are logically similar to **undefined** steps.

.. note::

    All steps following a pending step are not executed, as the
    behavior following it is unpredictable. These steps are marked as
    **skipped**.

.. tip::

    If you use ``--strict`` option with Behat, pending steps will cause Behat
    to exit with ``1`` code.

Failed Steps
~~~~~~~~~~~~

When a definition method throws any ``Exception`` (except ``PendingException``)
during execution, the step is marked as **failed**. Again, what you return from a
definition does not affect the passing or failing of the step. Returning ``null``
or ``false`` will not cause a step to fail.

Let's pretend, that your ``FeatureContext`` has following code:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /** @Given some step with :argument1 argument */
        public function someStepWithArgument($argument1)
        {
            throw new Exception('some exception');
        }

        /** @Given number step with :argument1 */
        public function numberStepWith($argument1)
        {
        }
    }

When you run your feature, you'll get 1 failing step that is marked red and
it will be followed by 1 skipped step that is marked cyan.

.. note::

    Failed steps are always marked as **red** if colors are supported by
    your console.

.. note::

    All steps within a scenario following a failed step are not executed, as the
    behavior following it is unpredictable. These steps are marked as
    **skipped**.

.. tip::

    If Behat finds a failed step during suite execution, it will exit with
    ``1`` code.

.. tip::

    Behat doesn't come with its own assertion tool, but you can use any proper assertion
    tool out there. Proper assertion tool is a library, which assertions throw
    exceptions on fail. For example, if you're familiar with PHPUnit, you can use
    its assertions in Behat by installing it via composer:

    .. code-block:: bash

        $ php composer.phar require --dev phpunit/phpunit='~4.1.0'

    and then by simply using assertions in your steps:

    .. code-block:: php

        PHPUnit_Framework_Assert::assertCount(intval($count), $this->basket);

.. tip::

    You can get exception stack trace with ``-vv`` option provided to Behat:

    .. code-block:: bash

        $ vendor/bin/behat features/example.feature -vv

Skipped Steps
~~~~~~~~~~~~~

Steps that follow **undefined**, **pending** or **failed** steps are never
executed, even if there is a matching definition. These steps are marked
**skipped**:

.. note::

    Skipped steps are always marked as **cyan** if colors are supported by
    your console.

Ambiguous Steps
~~~~~~~~~~~~~~~

When Behat finds two or more definitions that match a single step, this step is
marked as **ambiguous**.

Consider your ``FeatureContext`` has following code:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /** @Given /^.* step with .*$/ */
        public function someStepWithArgument()
        {
        }

        /** @Given /^number step with (\d+)$/ */
        public function numberStepWith($argument1)
        {
        }
    }

Executing Behat with this feature context will result in a ``Ambiguous``
exception being thrown.

Behat will not make a decision about which definition to execute. That's your
job! But as you can see, Behat will provide useful information to help you
eliminate such problems.

Redundant Step Definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~

Behat will not let you define a step expression's corresponding pattern more
than once. For example, look at the two ``@Given`` patterns defined in this
feature context:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /** @Given /^number step with (\d+)$/ */
        public function workWithNumber($number1)
        {
        }

        /** @Given /^number step with (\d+)$/ */
        public function workDifferentlyWithNumber($number1)
        {
        }
    }

Executing Behat with this feature context will result in a ``Redundant``
exception being thrown.

Step Argument Transformations
-----------------------------

Step argument transformations allow you to abstract common operations performed
on step definition arguments into reusable methods. In addition, these methods
can be used to transform a normal string argument that was going to be used
as an argument to a step definition method, into a more specific data type
or an object.

Each transformation method must return a new value. This value then replaces
the original string value that was going to be used as an argument to a step
definition method.

Transformation methods are defined using the same annotation style as step
definition methods, but instead use the ``@Transform`` keyword, followed by
a matching pattern.

As a basic example, you can automatically cast all numeric arguments to
integers with the following context class code:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /**
         * @Transform /^(\d+)$/
         */
        public function castStringToNumber($string)
        {
            return intval($string);
        }

        /**
         * @Then a user :name, should have :count followers
         */
        public function assertUserHasFollowers($name, $count)
        {
            if ('integer' !== gettype($count)) {
                throw new Exception('Integer expected');
            }
        }
    }

.. note::

    In the same way as with step definitions, you can use both simple patterns and
    regular expressions.

Let's go a step further and create a transformation method that takes an
incoming string argument and returns a specific object. In the following
example, our transformation method will be passed a username, and the method
will create and return a new ``User`` object:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        /**
         * @Transform :user
         */
        public function castUsernameToUser($user)
        {
            return new User($user);
        }

        /**
         * @Then a :user, should have :count followers
         */
        public function assertUserHasFollowers(User $user, $count)
        {
            if ('integer' !== gettype($count)) {
                throw new Exception('Integer expected');
            }
        }
    }

Transforming Tables
~~~~~~~~~~~~~~~~~~~

Let's pretend we have written the following feature:

.. code-block:: gherkin

    # features/table.feature
    Feature: Users

      Scenario: Creating Users
        Given the following users:
          | name          | followers |
          | everzet       | 147       |
          | avalanche123  | 142       |
          | kriswallsmith | 274       |
          | fabpot        | 962       |

And our ``FeatureContext`` class looks like this:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;
    use Behat\Gherkin\Node\TableNode;

    class FeatureContext implements Context
    {
        /**
         * @Given the following users:
         */
        public function pushUsers(TableNode $usersTable)
        {
            $users = array();
            foreach ($usersTable as $userHash) {
                $user = new User();
                $user->setUsername($userHash['name']);
                $user->setFollowersCount($userHash['followers']);
                $users[] = $user;
            }

            // do something with $users
        }
    }

A table like this may be needed in a step testing the creation of the
``User`` objects themselves, and later used again to validate other parts of
our codebase that depend on multiple ``User`` objects that already exist.
In both cases, our transformation method can take our table of usernames and
follower counts and build dummy ``User`` objects. By using a transformation
method we have eliminated the need to duplicate the code that creates our
``User`` objects, and can instead rely on the transformation method each time
this functionality is needed.

Transformations can also be used with tables. A table transformation is matched
via a comma-delimited list of the column headers prefixed with ``table:``:

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;
    use Behat\Gherkin\Node\TableNode;

    class FeatureContext implements Context
    {
        /**
         * @Transform table:name,followers
         */
        public function castUsersTable(TableNode $usersTable)
        {
            $users = array();
            foreach ($usersTable->getHash() as $userHash) {
                $user = new User();
                $user->setUsername($userHash['name']);
                $user->setFollowersCount($userHash['followers']);
                $users[] = $user;
            }

            return $users;
        }

        /**
         * @Given the following users:
         */
        public function pushUsers(array $users)
        {
            // do something with $users
        }

        /**
         * @Then I expect the following users:
         */
        public function assertUsers(array $users)
        {
            // do something with $users
        }
    }

.. note::

    Transformations are powerful and it is important to take care how you
    implement them. A mistake can often introduce strange and unexpected
    behavior. Also, they are inherently hard to debug because of their
    highly dynamic nature.

Browse your steps dictionary
----------------------------

As your set of features will grow, there's a good chance that the amount of
different steps that you'll have at your disposal to describe new scenarios will also grow.

Behat provides a command line option ``--definitions`` or simply ``-d`` to easily browse definitions
in order to reuse them or adapt them (introducing new placeholders for example).

For example, when using the Mink context provided by the Mink extension, you'll have access to its
step dictionary by running:

.. code-block:: console

    $ behat -di
    web_features | Given /^(?:|I )am on (?:|the )homepage$/
                 | Opens homepage.
                 | at `Behat\MinkExtension\Context\MinkContext::iAmOnHomepage()`

    web_features | When /^(?:|I )go to (?:|the )homepage$/
                 | Opens homepage.
                 | at `Behat\MinkExtension\Context\MinkContext::iAmOnHomepage()`

    web_features | Given /^(?:|I )am on "(?P<page>[^"]+)"$/
                 | Opens specified page.
                 | at `Behat\MinkExtension\Context\MinkContext::visit()`

    # ...

or, for a shorter output:

.. code-block:: console

    $ behat -dl
    web_features | Given /^(?:|I )am on (?:|the )homepage$/
    web_features |  When /^(?:|I )go to (?:|the )homepage$/
    web_features | Given /^(?:|I )am on "(?P<page>[^"]+)"$/
    web_features |  When /^(?:|I )go to "(?P<page>[^"]+)"$/
    web_features |  When /^(?:|I )reload the page$/
    web_features |  When /^(?:|I )move backward one page$/
    web_features |  When /^(?:|I )move forward one page$/
    # ...

You can also search for a specific pattern by running:

.. code-block:: console

    $ behat --definitions="field" (or simply behat -dfield)
    web_features | When /^(?:|I )fill in "(?P<field>(?:[^"]|\\")*)" with "(?P<value>(?:[^"]|\\")*)"$/
                 | Fills in form field with specified id|name|label|value.
                 | at `Behat\MinkExtension\Context\MinkContext::fillField()`

    web_features | When /^(?:|I )fill in "(?P<field>(?:[^"]|\\")*)" with:$/
                 | Fills in form field with specified id|name|label|value.
                 | at `Behat\MinkExtension\Context\MinkContext::fillField()`

    #...

That's it, you can now search and browse your whole step dictionary.
