Funcionalidades de teste
========================

Nós já usamos esta estranha classe ``FeatureContext`` como uma casa para nossa 
:doc:`definição de etapas </guides/2.definitions>` e :doc:`hooks </guides/3.hooks>`,
mas nós não temos feito muito para explicar o que realmente é.

Classes de contexto são uma pedra angular do meio ambiente de testes em Behat. 
A classe de contexto é uma simples POPO - Plain Old PHP Object (Ou traduzido 
literalmente: Objeto PHP Simples Velho) que diz ao Behat como testar as suas 
funcionalidades. Se todos arquivos ``*.feature`` descrevem *como* sua 
aplicação se comporta, então a classe de contexto é sobre como testar isso.

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\Context;

    class FeatureContext implements Context
    {
        public function __construct($parametro)
        {
            // instanciar contexto
        }

        /** @BeforeFeature */
        public static function prepararParaAFuncionalidade()
        {
            // limpar o banco de dados ou fazer outras preparações
        }

        /** @Given nós temos algum contexto */
        public function prepararContexto()
        {
            // fazer algo
        }

        /** @When ocorrer um evento */
        public function fazerAlgumaAcao()
        {
            // fazer algo
        }

        /** @Then algo deve ser feito */
        public function checar()
        {
            // fazer algo
        }
    }

Um mnemônico simples para classes de contexto é "testar funcionalidades *em um contexto*".
Descrições de funcionalidades tendem ser muito alto nível. Isto siginifca que 
não há muito detalhe técnico exposto neles, então o caminho para você testar 
essa linda funcionalidade depende do contexto em que seu teste está contido. 
Isso é o que as classes de contexto são.

Requerimentos de Classe de Contexto
-----------------------------------

A fim de ser usado pelo Behat, sua classe de contexto deve seguir as seguintes regras:

#. A classe de contexto deve implementar a interface ``Behat\Behat\Context\Context``.

#. A classe de contexto deve ser chamada ``FeatureContext``. É uma simples 
   convenção dentro da infraestrutura do Behat. ``FeatureContext`` é o nome da 
   sua classe de contexto para uma suite padrão. Isto pode ser facilmente 
   alterado através da configuração da suite dentro de ``behat.yml``.

#. A classe de contexto deve ser detectável e carregável pelo Behat. Isso 
   significa que você deve de alguma forma dizer ao Behat sobre o arquivo 
   de classe. O Behat vem com uma PSR-0 carregamento automático fora e o 
   carregamento automático de diretório padrão é ``features/bootstrap``. 
   É por isso que é carregado o padrão ``FeatureContext`` tão fácil pelo Behat. 
   Você pode colocar suas próprias classes sob ``features/bootstrap`` seguindo 
   a convenção PSR-0 ou você pode até definir seu próprio arquivo auto 
   carregável em ``behat.yml``.

.. note::

    ``Behat\Behat\Context\SnippetAcceptingContext`` e 
    ``Behat\Behat\Context\CustomSnippetAcceptingContext`` são versões
    especiais da interface ``Behat\Behat\Context\Context`` que dizem 
    ao Behat neste contexto, espera fragmentos a ser gerado por ele.

A forma mais fácil de começar a utilizar o Behat em seu projeto é chamar 
o ``behat`` com a opção ``--init`` dentro do diretório do seu projeto:

.. code-block:: bash

    $ vendor/bin/behat --init

O Behat irá criar um alguns diretórios e uma classe esqueleto ``FeatureContext``
dentro do seu projeto.

.. code-block:: php

    // features/bootstrap/FeatureContext.php

    use Behat\Behat\Context\SnippetAcceptingContext;
    use Behat\Gherkin\Node\PyStringNode;
    use Behat\Gherkin\Node\TableNode;

    class FeatureContext implements SnippetAcceptingContext
    {
        /**
         * Initializes context.
         */
        public function __construct()
        {
        }
    }


Contexts Lifetime
-----------------

Your context class is initialized before each scenario is run, and every scenario
has its very own context instance. This means 2 things:

#. Every scenario is isolated from each other scenario's context. You can do
   almost anything inside your scenario context instance without the fear of
   affecting other scenarios - every scenario gets its own context instance.

#. Every step in a single scenario is executed inside a common context
   instance. This means you can set ``private`` instance variables inside
   your ``@Given`` steps and you'll be able to read their new values inside
   your ``@When`` and ``@Then`` steps.

Multiple Contexts
-----------------

At some point, it could become very hard to maintain all your
:doc:`step definitions </guides/2.definitions>` and :doc:`hooks </guides/3.hooks>`
inside a single class. You could use class inheritance and split definitions
into multiple classes, but doing so could cause your code to become more
difficult to follow and use.

In light of these issues, Behat provides a more flexible way of helping make
your code more structured by allowing you to use multiple contexts in a single test
suite.

In order to customise the list of contexts your test suite requires, you need
to fine-tune the suite configuration inside ``behat.yml``:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - FeatureContext
                    - SecondContext
                    - ThirdContext

The first ``default`` in this configuration is a name of the profile. We
will discuss :doc:`profiles </guides/6.profiles>` a little bit later. Under
the specific profile, we have a special ``suites`` section, which
configures suites inside this profile. We will talk about test suites in more
detail in the :doc:`next chapter </guides/5.suites>`, for now just keep in mind
that a suite is a way to tell Behat where to find your features and
how to test them. The interesting part for us now is the ``contexts``
section - this is an array of context class names. Behat will use the classes
specified there as your feature contexts. This means that every time
Behat sees a scenario in your test suite, it will:

#. Get list of all context classes from this ``contexts`` option.

#. Will try to initialize all these context classes into objects.

#. Will search for :doc:`step definitions </guides/2.definitions>` and
   :doc:`hooks </guides/3.hooks>` in all of them.

.. note::

    Do not forget that each of these context classes should follow all
    context class requirements. Specifically - they all should implement
    ``Behat\Behat\Context\Context`` interface and be autoloadable by
    Behat.

Basically, all contexts under the ``contexts`` section of your ``behat.yml``
are the same for Behat. It will find and use the methods in them the same way
it does in the default ``FeatureContext``. And if you're happy with a single
context class, but you don't like the name ``FeatureContext``, here's
how you change it:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - MyAwesomeContext

This configuration will tell Behat to look for ``MyAwesomeContext``
instead of the default ``FeatureContext``.

.. note::

    Unlike :doc:`profiles </guides/6.profiles>`, Behat will not inherit any
    configuration of your ``default`` suite. The name ``default`` is only used
    for demonstration purpose in this guide. If you have multiple suites that
    all should use the same context, you will have to define that specific
    context for every specific suite:

    .. code-block:: yaml

        # behat.yml

        default:
            suites:
                default:
                    contexts:
                        - MyAwesomeContext
                        - MyWickedContext
                suite_a:
                    contexts:
                        - MyAwesomeContext
                        - MyWickedContext
                suite_b:
                    contexts:
                        - MyAwesomeContext

    This configuration will tell Behat to look for ``MyAwesomeContext`` and
    ``MyWickedContext`` when testing ``suite_a`` and ``MyAwesomeContext`` when
    testing ``suite_b``. In this example, ``suite_b`` will not be able to call
    steps that are defined in the ``MyWickedContext``. As you can see, even if
    you are using the name ``default`` as the name of the suite, Behat will not
    inherit any configuration from this suite.

Context Parameters
------------------

Context classes can be very flexible depending on how far you want
to go in making them dynamic. Most of us will want to make our contexts 
environment-independent; where should we put temporary files, which URLs 
will be used to access the application? These are
context configuration options highly dependent on the environment you
will test your features in.

We already said that context classes are just plain old PHP classes.
How would you incorporate environment-dependent parameters into your
PHP classes? Use *constructor arguments*:

.. code-block:: php

    // features/bootstrap/MyAwesomeContext.php

    use Behat\Behat\Context\Context;

    class MyAwesomeContext implements Context
    {
        public function __construct($baseUrl, $tempPath)
        {
            $this->baseUrl = $baseUrl;
            $this->tempPath = $tempPath;
        }
    }

As a matter of fact, Behat gives you ability to do just that. You can
specify arguments required to instantiate your context classes through
same ``contexts`` setting inside your ``behat.yml``:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - MyAwesomeContext:
                        - http://localhost:8080
                        - /var/tmp

.. note::

    Note an indentation for parameters. It is significant:

    .. code-block:: yaml

        contexts:
            - MyAwesomeContext:
                - http://localhost:8080
                - /var/tmp

    Aligned four spaces from the context class itself.

Arguments would be passed to the ``MyAwesomeContext`` constructor in
the order they were specified here. If you are not happy with the idea
of keeping an order of arguments in your head, you can use argument
names instead:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - MyAwesomeContext:
                        baseUrl: http://localhost:8080
                        tempPath: /var/tmp

As a matter of fact, if you do, the order in which you specify these
arguments becomes irrelevant:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - MyAwesomeContext:
                        tempPath: /var/tmp
                        baseUrl: http://localhost:8080

Taking this a step further, if your context constructor arguments are
optional:

.. code-block:: php

    public function __construct($baseUrl = 'http://localhost', $tempPath = '/var/tmp')
    {
        $this->baseUrl = $baseUrl;
        $this->tempPath = $tempPath;
    }

You then can specify only the parameter that you actually need to change:

.. code-block:: yaml

    # behat.yml

    default:
        suites:
            default:
                contexts:
                    - MyAwesomeContext:
                        tempPath: /var/tmp

In this case, the default values would be used for other parameters.

Context Traits
--------------

PHP 5.4 have brought an interesting feature to the language - traits.
Traits are a mechanism for code reuse in single inheritance languages
like PHP. Traits are implemented as a compile-time copy-paste in PHP.
That means if you put some step definitions or hooks inside a trait:

.. code-block:: php

    // features/bootstrap/ProductsDictionary.php

    trait ProductsDictionary
    {
        /**
         * @Given there is a(n) :arg1, which costs £:arg2
         */
        public function thereIsAWhichCostsPs($arg1, $arg2)
        {
            throw new PendingException();
        }
    }

And then use it in your context:

.. code-block:: php

    // features/bootstrap/MyAwesomeContext.php

    use Behat\Behat\Context\Context;

    class MyAwesomeContext implements Context
    {
        use ProductsDictionary;
    }

It will just work as you expect it to.

Context traits come in handy if you'd like to have separate contexts,
but still need use the very same step definition in both of them. Instead of
having the same code in both context classes – and having to maintain it
in both – you should create a single Trait that you would then ``use`` in
both context classes.

.. note::

    Given that step definitions :doc:`cannot be duplicated within a Suite </guides/2.definitions>`,
    this will only work for contexts used in separate suites.

    In other words, if your Suite uses at least two different Contexts, and
    those context classes ``use`` the same Trait, this will result in a duplicate
    step definition and behat will complain by throwing a ``Redundant`` exception.
