Escrevendo Features
===================

Behat é uma ferramenta para testar o o comportamento
de seua aplicação, escrito em uma linguagem especial
chamada Gherkin. Gherkin é uma `Business Readable, Domain Specific Language <http://martinfowler.com/bliki/BusinessReadableDSL.html>`_ creada especificamente
para a descrição de comportamentos. Isto lhe dá a habilidade
de remover detalhes lógicos dos testes de comportamento.

Gherkin serve como documentação do seu projeto, bem como
para testes automatizados. Behat também tem uma característica
bonus: Ele fala para você usando linguagem verdadeira, humana 
dizendo a você o código que você deve escrever.

    Dica:

    Se você ainda é novo no Behat, vá para :doc:`/quick_intro_pt1` 
    primeiro,então retorne aqui para aprender mais sobre Gherkin.

Sintaxe Gherkin
---------------

Bem como UAML e Python, Gherkin é uma linguagem orientada a espaços, ela
usa identação para definir a estrutura. Os fins de linha encerram as 
declarações (denominados steps) e espaços ou tabs também podem ser usados
para identação (nós sugerimos a você usar espaços para portabilidade).
Finalmente, a maioria das linhas em Gherkin iniciam com uma palavra
chave especial:

.. code-block:: gherkin

    # language: pt
    Funcionalidade: Algum texto descritivo conciso do que é desejado
      A fim de realizar um valor de negócio
      Como ator explicito do sistema
      Eu quero ganhar algum resultado benéfico que promova a meta 

     Texto adicional...
 
      Cenário: Uma determinada situação de negócios
        Dado uma pré condição
        E uma outra pŕe condição
        Quando uma ação feita pelo ator
        E uma outra ação
        E outra ação diferente
        Então um resultado testável é alcançado
        E outra coisa que possamos verificar também acontece
 
      Cenário: Uma situação diferente
        ...

O analizador divide a entrada em funcionalidades, cenários e etapas.
Vamos analizar o exemplo:

.# ``Funcionalidade: Algum texto descritivo conciso do que é desejado`` 
    inicia a feature e lhe dá um título. Aprenda mais sobre funcionalidades
    na seção "`Features`_".

.# As próximas três linhas (``A fim de ...``, ``Como um ...``, ``Eu quero...``)
    dão um contexto fornecem um contexto para as pessoas que lêem o seu recurso 
    e descreve o valor do negócio derivada da inclusão do recurso em seu software.
    Estas linhas não são analisadas pelo Behat e não requerem uma estrutura.
    
.# ``Cenário: Uma determinada situação de negócios`` inicia o cenário e
    contêm uma descrição do cenário. Aprenda mais sobre cenários na seção 
    "`Scenarios`_" 
    
.# As próximas 7 linhas são etapas do cenário, cada um dos quais é comparado
    com um padrão definido em outro lugar. Aprenda mais sobre etapas na
    seção "`Steps`_"

.# ``Cenário: Uma situação diferente`` inicia o próximo e cenário assim por diante.

Quando você está executando a funcionalidade, a porção da direita de cada passo
(após as palavras chaves como ``Dado``, ``E``, ``Quando``, etc) coincide com 
um padrão, que executa uma função callback do PHP. Você pode ler mais sobre 
etapas de coincidencias e execução em :doc:`/guides/2.definitions`.

Funcionalidades
---------------

Todos arquivos ``*.feature`` convencionalmente consistem em uma funcionalidade 
única. Linhas iniciando com a palavra chave ``Funcionalidade:`` (ou o seu 
equivalente) seguido de três linhas identadas iniciam uma funcionalidade. 
Usualmente uma feature contém uma lista de cenários. Você pode escrever 
qualquer coisa que você precise até o primeiro cenário, que inicia com 
``Cenário:`` (ou o seu equivalente) em uma nova linha. Você pode usar
`tags`_ para agrupar funcionalidades e cenários, independente da estrutura
do seu arquivo e diretório.

Todos cenários consistem em uma lista de `etapas`_, que devem iniciar com
uma das palvras chaves ``Dado``, ``Quando``, ``Então``, ``Mas`` ou ``E``
(ou o equivalente de um destes). O Behat trata eles do mesmo modo, mas
você não deve fazer isto.
Aqui temos um exemplo:

.. code-block:: gherkin

    # language: pt
    Funcionalidade: Servir café
        A fim de ganhar dinheiro
        Os clientes devem ser capazes de
        comprar café a todo momento

      Cenário: Compra último café
        Dado que tenha 1 café sobrando na máuqina
        E eu tenha depositado 1 real
        Quando eu pressionar o botão de café
        Então eu deveria ser servido de um café

Além do básico `Cenário`_, uma feature pode conter `Esquema do Cenário`_
e `Contexto`_.

Cenário
-------

Cenários são uma das principais estruturas do Gherkin. Todo cenário deve 
iniciar com a palavra chave ``Cenário:`` (ou palavra chave equivalente),
opcionalmente seguido de um título de cenário. Cada funcionalidade pode 
ter um ou mais cenários e todo cenário consiste em um ou mais `etapa`_.

Os cenários seguintes tem cada um 3 etapas:

.. code-block:: gherkin

    Cenário: Wilson posta em seu blog
      Dado que eu estou logado como Wilson
      Quando eu tento postar "A terapia cara"
      Então eu devo ver "Seu artigo foi publicado."

    Cenário: Wilson falha ao postar algo no blog de outra pessoa
      Dado que eu estou logado como Wilson
      Quando eu tento postar "Greg esbraveja contra impostos"
      Então eu devo ver "Hey! Este não é o seu blog!"

    Cenário: Greg posta em blog cliente
      Dado que eu estou logado como Greg
      Quando eu tento postar "Terapia Cara"
      Então eu devo ver "Seu artigo foi publicado."

Esquema do Cenário
------------------

Copiar e colar cenários para usar diferentes valores pode ser muito 
tedioso e repetitivo:

.. code-block:: gherkin

    Cenário: Comer 5 em cada 12
      Dado que tenho 12 pepinos
      Quando eu comer 5 peninos
      Então eu devo ter 7 pepinos

    Cenário: Comer 5 em cada 20
      Dado que tenho 20 pepinos
      Quando eu comer 5 peninos
      Então eu devo ter 15 pepinos    

Os `Esquema de Cenários` nos permitem formular estes exemplos com maior precisão 
através da utilização de um modelo com espaços reservados:

.. code-block:: gherkin

    Esquema do Cenário: Comendo
      Dado que tenho <antes> pepinos
      Quando eu comer <come> pepinos
      Então eu devo ter <depois> pepinos

      Exemplos:
        | antes | come | depois |
        |  12   |  5   |   7    |
        |  20   |  5   |   15   |

As etapas do Esquema do Cenário fornecem um modelo que nunca é executado
diretamente. Um Esquema do Cenário é executado uma vez para cada linha 
na seção de exemplos abaixo dela (exceto para a primeira linha 
que é o cabeçalho).

O Esquema do Cenário utiliza espaços reservados, que estão
contidos ``< >`` nas etapas de saída do Cenário. Por exemplo:

.. code-block:: gherkin

    Dado <Eu sou um espaço reservado e estou ok>

Pense em um espaço reservado como uma variável. Isto pode ser substituido
por um valor real das linhas da tabela de ``Exemplos:``, onde o texto 
entre o ângulo de espaço em reservado corresponde ao que o cabeçalho da
coluna da tabela. O valor substituido pelo espaço reservado muda a cada 
execução subsequente do Esquema do Cenário, até que o fim da tabela de
``Exemplos`` seja alcançado.

.. tip::

    Vocẽ também pode usar os espaços reservados em `Argumentos 
    múltilinhas`_.

.. note::

    Sua etapa de definições nunca terá que coincidir com o próprio texto 
    do espaço reservado, mas sim os valores terão que substituir o 
    espaço reservado.

Então quando executamos a primeira linha do nosso exemplo:

.. code-block:: gherkin

    Esquema do Cenário: Comer
      Dado que temos <antes> pepinos
      Quando eu comer <come> pepino
      Então teremos <depois> pepinos

      Exemplos:
        | antes | come | depois |
        |  12   |   5  |   7    |

O cenário que realmente é executado é:

.. code-block:: gherkin

    Cenário: Comer
      # <antes> é substituido por 12:
      Dado que temos 12 pepinos
      # <come> é substituido por 5:
      Quando eu comer 5 pepino
      # <depois> é substituido por 7:
      Então teremos 7 pepinos

Contexto
--------

Contexto permite a você adicionar algum contexto a todos os cenários em 
um único recurso. Um Contexto é como um Cenário sem título, que contém
uma série de etapas. A diferença ocorre quando ele é executado: o 
contexto está executando *antes de cada* um de seus cenários, mas depois 
dos seus hooks ``BeforeScenario`` (:doc:`/guides/3.hooks`).

.. code-block:: gherkin

    # language: pt
    Funcionalidade: Suporte a múltiplos sites
    
    Contexto: 
        Dado um administrador global chamado "Greg"
        E um blog chamado "Greg esbraveja contra impostos"
        E um cliente chamado "Wilson"
        E um blog chamado "Terapia Cara" de própriedade de "Wilson"
    
    Cenário: Wilson posta em seu próprio blog
        Dado que eu esteja logado como Wilson
        Quando eu tentar postar em "Terapia Cara"
        Então eu devo ver "Seu artigo foi publicado."

    Cenário: Greg posta no blog de um cliente
        Dado que eu esteja logado como Greg
        Quando eu tentar postar em "Terapia Cara"
        Então eu devo ver "Seu artigo foi publicado"


Etapas
------

`Funcionalidades`_ consiste em etapas, também conhecido como `Dado`_, 
`Quando`_ e ``Então_.

O Behat não tem uma distinção técnica entre estes três tipos de etapas.
Contudo, nós recomendamos fortemente que você faça! Estas palavras
foram cuidadosamente selecionadas para o seus propósito e você deve
saber que o objetivo é entrar na mentalidade BDD.

Robert C. Martin escreveu um 
`ótimo post <https://sites.google.com/site/unclebobconsultingllc/the-truth-about-bdd>`_ 
sobre o conceito de BDD Dado-Quando-Então onde ele pensa neles como uma 
máquina de estados finitos.

Dado
~~~~

O propósito da etapa **Dado** é **colocar o sistema em um estado conhecido** 
antes do usuário (ou sistema externo) iniciar a interalção com o sistema
(na etapa Quando). Evite falar sobre a interação em Dado. Se você trabalhou
com casos de uso, Dado é a sua pré condição.

.. sidebar:: Exemplos de Dado

    Dois bons exemplos do uso de **Dado** são:

    * Crear 

    * Para criar registros (instâncias de modelo) ou de configuração do 
    banco de dados:

      .. code-block:: gherkin

          Dado que não tenha usuários no site
          Dado que o banco de dados esteja limpo

    * Autenticar um usuário (uma exceção para )

    * Autenticar um usuário (uma exceção a recomendação não-interação 
    Coisas que "aconteceram antes" estão ok.):

      .. code-block:: gherkin

          Dado que eu esteja logado como "Everzet"

.. tip::

    Tudo bem chamar a camada de "dentro" da camada de interface do 
    usuário aqui (em Symfony: falar com os modelos).

.. sidebar:: Usando Dado como massa de dados:

    Se você usa ORMs como Doctrine ou Propel, nós recomendamos a utilização
    de uma etapa Dado com o argumento `tabela`_ para configurar registros 
    em vez de objetos. Neste caminho você pode ler todos os cenários em um
    único lugar e fazer sentido fora dele sem ter que saltar entre arquivos: 

    .. code-block:: gherkin

        Dado estes usuários:
        | username | password | email               |
        | everzet  | 123456   | everzet@knplabs.com |
        | fabpot   | 22@222   | fabpot@symfony.com  |

Quando
~~~~~~

The purpose of **When** steps is to **describe the key action** the user
performs (or, using Robert C. Martin's metaphor, the state transition).

.. sidebar:: When Examples

    Two good examples of using **Whens** are:

    * Interact with a web page (the Mink library gives you many web-friendly
      ``When`` steps out of the box):

      .. code-block:: gherkin

          When I am on "/some/page"
          When I fill "username" with "everzet"
          When I fill "password" with "123456"
          When I press "login"

    * Interact with some CLI library (call commands and record output):

      .. code-block:: gherkin

          When I call "ls -la"

Thens
~~~~~

The purpose of **Then** steps is to **observe outcomes**. The observations
should be related to the business value/benefit in your feature description.
The observations should inspect the output of the system (a report, user
interface, message, command output) and not something deeply buried inside it
(that has no business value and is instead part of the implementation).

.. sidebar:: Then Examples

    Two good examples of using **Thens** are:

    * Verify that something related to the Given + When is (or is not) in the
      output:

      .. code-block:: gherkin

          When I call "echo hello"
          Then the output should be "hello"

    * Check that some external system has received the expected message:

      .. code-block:: gherkin

          When I send an email with:
            """
            ...
            """
          Then the client should receive the email with:
            """
            ...
            """

.. caution::

    While it might be tempting to implement Then steps to just look in the
    database – resist the temptation. You should only verify output that is
    observable by the user (or external system). Database data itself is
    only visible internally to your application, but is then finally exposed
    by the output of your system in a web browser, on the command-line or an
    email message.

And, But
~~~~~~~~

If you have several Given, When or Then steps you can write:

.. code-block:: gherkin

    Scenario: Multiple Givens
      Given one thing
      Given another thing
      Given yet another thing
      When I open my eyes
      Then I see something
      Then I don't see something else

Or you can use **And** or **But** steps, allowing your Scenario to read more
fluently:

.. code-block:: gherkin

    Scenario: Multiple Givens
      Given one thing
      And another thing
      And yet another thing
      When I open my eyes
      Then I see something
      But I don't see something else

Behat interprets steps beginning with And or But exactly the same as all other
steps; it doesn't differentiate between them - you should!

Multiline Arguments
-------------------

The one line `steps`_ let Behat extract small strings from your steps
and receive them in your step definitions. However, there are times when you
want to pass a richer data structure from a step to a step definition.

This is what multiline step arguments are designed for. They are written on
lines immediately following a step and are passed to the step definition
method as the last argument.

Multiline step arguments come in two flavours: `tables`_ or `pystrings`_.

Tables
~~~~~~

Tables as arguments to steps are handy for specifying a larger data set -
usually as input to a Given or as expected output from a Then.

.. code-block:: gherkin

    Scenario:
      Given the following people exist:
        | name  | email           | phone |
        | Aslak | aslak@email.com | 123   |
        | Joe   | joe@email.com   | 234   |
        | Bryan | bryan@email.org | 456   |

.. attention::

    Don't confuse tables with `scenario outlines`_ - syntactically
    they are identical, but they have a different purpose. Outlines declare
    multiple different values for the same scenario, while tables are used to
    expect a set of data.

.. sidebar:: Matching Tables in your Step Definition

    A matching definition for this step looks like this:

    .. code-block:: php

        use Behat\Gherkin\Node\TableNode;

        // ...

        /**
         * @Given the following people exist:
         */
        public function thePeopleExist(TableNode $table)
        {
            foreach ($table as $row) {
                // $row['name'], $row['email'], $row['phone']
            }
        }

    A table is injected into a definition as a ``TableNode`` object, from
    which you can get hash by columns (``TableNode::getHash()`` method) or by
    rows (``TableNode::getRowsHash()``).

PyStrings
~~~~~~~~~

Multiline Strings (also known as PyStrings) are useful for specifying a
larger piece of text. The text should be offset by delimiters consisting of
three double-quote marks (``"""``), placed on their own line:

.. code-block:: gherkin

    Scenario:
      Given a blog post named "Random" with:
        """
        Some Title, Eh?
        ===============
        Here is the first paragraph of my blog post.
        Lorem ipsum dolor sit amet, consectetur adipiscing
        elit.
        """

.. note::

    The inspiration for PyString comes from Python where ``"""`` is used to
    delineate docstrings, much in the way ``/** ... */`` is used for multiline
    docblocks in PHP.

.. sidebar:: Matching PyStrings in your Step Definition

    In your step definition, there's no need to find this text and match it in
    your pattern. The text will automatically be passed as the last
    argument into the step definition method. For example:

    .. code-block:: php

        use Behat\Gherkin\Node\PyStringNode;

        // ...

        /**
         * @Given a blog post named :title with:
         */
        public function blogPost($title, PyStringNode $markdown)
        {
            $this->createPost($title, $markdown->getRaw());
        }

    PyStrings are stored in a ``PyStringNode`` instance, which you can simply
    convert to a string with ``(string) $pystring`` or ``$pystring->getRaw()``
    as in the example above.

.. note::

    Indentation of the opening ``"""`` is not important, although common practice
    is two spaces in from the enclosing step. The indentation inside the triple
    quotes, however, is significant. Each line of the string passed to the step
    definition's callback will be de-indented according to the opening ``"""``.
    Indentation beyond the column of the opening ``"""`` will therefore be
    preserved.

Tags
----

Tags are a great way to organize your features and scenarios. Consider this
example:

.. code-block:: gherkin

    @billing
    Feature: Verify billing

      @important
      Scenario: Missing product description

      Scenario: Several products

A Scenario or Feature can have as many tags as you like, just separate them
with spaces:

.. code-block:: gherkin

    @billing @bicker @annoy
    Feature: Verify billing

.. note::

    If a tag exists on a ``Feature``, Behat will assign that tag to all
    child ``Scenarios`` and ``Scenario Outlines`` too.

Gherkin in Many Languages
-------------------------

Gherkin is available in many languages, allowing you to write stories
using localized keywords from your language. In other words, if you
speak French, you can use the word ``Fonctionnalité`` instead of ``Feature``.

To check if Behat and Gherkin support your language (for example, French),
run:

.. code-block:: bash

    behat --story-syntax --lang=fr

.. note::

    Keep in mind that any language different from ``en`` should be explicitly
    marked with a ``# language: ...`` comment at the beginning of your
    ``*.feature`` file:

    .. code-block:: gherkin

        # language: fr
        Fonctionnalité: ...ta
          ...

    This way your features will hold all the information about its content
    type, which is very important for methodologies like BDD and also gives
    Behat the ability to have multilanguage features in one suite.

